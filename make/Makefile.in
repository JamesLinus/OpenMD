#---------------------------------------------------------------------------
#  (C) 1999 - 2002 Jacob Dreyer - Geotechnical Software Services
#  jacob.dreyer@geosoft.no - http://geosoft.no
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, 
#  MA  02111-1307, USA.
#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  GnuMake crash course:
#
#  target : depends
#    rule
#
#  target  - the parameter given to make. I.e. what to build
#  depends - file or other targets target depends on
#  rule    - how to create target (note that rule is preceeded by a TAB char)
#  $(VAR)  - environment variable or variable defined above
#  $@      - Current target
#  $*      - Current target without extension
#  $<      - Current dependency
#
#---------------------------------------------------------------------------
IS_UNIX=1

#packages containing libraries
PackageLibs = \
	utils \
	visitors \
	math \
	types \
	primitives \
	UseTheForce/DarkSide \
	UseTheForce \
	brains \
	io \
	integrators\
	constraints \
	minimizers \
	selection \
	restraints \
	lattice \
	openbabel

#packages containing applications
Applications = \
	applications/oopse \
	applications/dump2Xyz \
	applications/staticProps \
	applications/dynamicProps \
        applications/simpleBuilder\
	applications/nanoRodBuilder \
	applications/mdinConverter

Samples = \
	samples/argon \
        samples/water/dimer \
	samples/water/spce \
	samples/water/ssd \
	samples/water/ssde \
	samples/water/ssdrf \
	samples/water/ssd-ion \
	samples/water/tip3p_ice \
	samples/water/tip4p \
	samples/lipid \
	samples/alkane \
	samples/minimizer \
	samples/metals \
	samples/thermoIntegration/liquid \
	samples/thermoIntegration/solid \
	samples/dipole \
        samples/shape \
	samples/zcons \

IncludeDirs = \
	@CGAL_INC_DIR@ \
	@MPI_INC_DIR@ 

LibraryDirs = \
	@CGAL_LIB_DIR@ \
	@MPI_LIB_DIR@ 

Libraries = \
	@LIBS@ \
	@CGAL_LIBS@ \
	@MPI_LIB@ \
	@MPI_F90_LIB@ 

OopseHome       = @OOPSE_HOME@
ForceParamDir   = $(OopseHome)/share/forceFields
SampleSimDir    = $(OopseHome)/share/samples
InstallBinDir   = $(OopseHome)/bin
DocDir          = $(OopseHome)/doc
FrcDeclare      = -DFRC_PATH="$(ForceParamDir)"
F90Declare      = -D__FORTRAN90
ParallelDeclare = -DIS_MPI
UseMPI          = @USE_MPI@
ModuleCase      = @F90_MODULE_NAMES@
ModSuffix       = @MOD@
LinkOptions = \
	@F90LIBS@ 

ParallelLinkOptions = \
	@F90LIBS@ 


#---------------------------------------------------------------------------
#
#  Directories
#
#---------------------------------------------------------------------------

SourceDir         = $(DEV_ROOT)/src
TargetDir         = $(DEV_ROOT)/obj
ParallelTargetDir = $(DEV_ROOT)/MPIobj
LibDir            = $(DEV_ROOT)/lib
MakeDir           = $(DEV_ROOT)/make
MainMakefile      = $(MakeDir)/Makefile
BinDir            = $(DEV_ROOT)/bin
DocsDir           = $(DEV_ROOT)/docs
CurrentDir        = $(CURDIR)
CombinedStaticLib = $(LibDir)/libOOPSE.a
CombinedParallelStaticLib = $(LibDir)/libOOPSE_MPI.a

ifdef Source
#get the relative path of current package to source directory
# /home/maul/gezelter/src/code/src/UseTheForce/Darkside --> UseTheForce/Darkside
#Package          = $(shell echo $(CurrentDir) | sed -e 's/^.*\/src\/\(.*\)/\1/g')
#use shell script to get the absolute path and then rip it off from $(CurrentDir)
#Package          = $(subst $(shell cd $(SourceDir); pwd)/,,$(CurrentDir))
# REMINDER: We are now using the Package line in each subdir makefile.
# This avoids the strange path problem and the subshell

PackageList              = $(Package)
PackageSourceDir         = $(SourceDir)/$(Package)
PackageTargetDir         = $(TargetDir)
PackageParallelTargetDir = $(ParallelTargetDir)
JavaMainClass            = $(subst /,.,$(Package)).$(Main)
else
PackageList              = $(PackageLibs) $(JavaPackages) $(Applications)
endif

PackageListLoop          = $(patsubst %,$(SourceDir)/%/.loop,$(PackageList))

JRE                      = $(JAVA_HOME)/jre/lib/rt.jar

ifdef IS_UNIX
X = :
else
X = \;
endif

#---------------------------------------------------------------------------
#
#  Classification of files
#
#---------------------------------------------------------------------------

# Source
JavaFiles              = $(filter %.java,  $(Source))
CppFiles               = $(filter %.cpp,   $(Source))
CFiles                 = $(filter %.c,     $(Source))
FortranFiles           = $(filter %.f,     $(Source))
F90Files               = $(filter %.F90,   $(Source))
CorbaFiles             = $(filter %.idl,   $(Source))
LexFiles               = $(filter %.l,     $(Source))
YaccFiles              = $(filter %.y,     $(Source))
OtherSourceFiles       = $(filter-out $(JavaFiles) $(CppFiles) $(CFiles) \
		                      $(FortranFiles) $(F90Files) $(LexFiles) \
	                              $(YaccFiles) $(CorbaFiles), \
	                              $(Source))
ManifestFile           = $(PackageSourceDir)/Manifest

SourceFiles            = $(JavaFiles)\
                         $(CppFiles)\
                         $(CFiles)\
                         $(FortranFiles)\
                         $(F90Files)\
                         $(LexFiles)\
                         $(YaccFiles)

# Target
JavaClassFiles         = $(JavaFiles:%.java=  $(PackageTargetDir)/%.class)
JavaClassFilesRel      = $(JavaFiles:%.java=  $(Package)/%.class)
RmiStubFiles           = $(RmiSource:%.java=  $(PackageTargetDir)/%_Stub.class)
RmiSkeletonFiles       = $(RmiSource:%.java=  $(PackageTargetDir)/%_Skel.class)
JniClassFiles          = $(JniSource:%.java=  $(PackageTargetDir)/%.class)
JniHeaders             = $(JniSource:%.java=  $(PackageSourceDir)/%.h)
ObjectFiles            = $(CFiles:%.c=        $(PackageTargetDir)/%.o)\
                         $(CppFiles:%.cpp=    $(PackageTargetDir)/%.o)\
		         $(FortranFiles:%.f=  $(PackageTargetDir)/%.o)\
		         $(F90Files:%.F90=    $(PackageTargetDir)/%.o)\
		         $(LexFiles:%.l=      $(PackageTargetDir)/%.o)\
		         $(YaccFiles:%.y=     $(PackageTargetDir)/%.o)
ParallelObjectFiles    = $(CFiles:%.c=        $(PackageParallelTargetDir)/%.o)\
		         $(CppFiles:%.cpp=    $(PackageParallelTargetDir)/%.o)\
		         $(FortranFiles:%.f=  $(PackageParallelTargetDir)/%.o)\
		         $(F90Files:%.F90=    $(PackageParallelTargetDir)/%.o)\
		         $(LexFiles:%.l=      $(PackageParallelTargetDir)/%.o)\
		         $(YaccFiles:%.y=     $(PackageParallelTargetDir)/%.o)

DerivedSource          = $(YaccFiles:%.y=    %.h) \
	                 $(YaccFiles:%.y=    %.c) \
	                 $(LexFiles:%.l=     %.c)

DerivedCFiles          = $(YaccFiles:%.y=    %.c) \
	                 $(LexFiles:%.l=     %.c)

OtherTargetFiles       = $(OtherSourceFiles:%=$(PackageTargetDir)/%)

###########################################################################
#
# Figure out the names of the module files based on some work done by
# configure.  The tr function below is from John Graham-Cumming
# (http://www.jgc.org). 
#
# The tr function.   Has three arguments:
#
# $1   The list of characters to translate from
# $2   The list of characters to translate to
# $3   The text to translate
#
# For example, $(call tr,A B C,1 2 3,CAPITAL) becomes 21PIT1L.

tr = $(eval __t := $3)                                                    \
     $(foreach c,                                                         \
         $(join $(addsuffix :,$1),$2),                                    \
         $(eval __t :=                                                    \
             $(subst $(word 1,$(subst :, ,$c)),$(word 2,$(subst :, ,$c)), \
                 $(__t))))$(__t)

# Common character classes for use with the tr function.  Each of
# these is actually a variable declaration and must be wrapped with
# $() or ${} to be used.

[A-Z] := A B C D E F G H I J K L M N O P Q R S T U V W X Y Z #
[a-z] := a b c d e f g h i j k l m n o p q r s t u v w x y z #
[0-9] := 0 1 2 3 4 5 6 7 8 9 #
[A-F] := A B C D E F #

# Figure out whether we have $(eval) or not (GNU Make 3.80 and above)
# if we do not then we need to use the shell version of tr, and not the
# faster tr function above:

__have_eval := $(false)
__ignore := $(eval __have_eval := $(true))

ifndef __have_eval
  uc = $(shell echo $1 | tr "a-z" "A-Z")
  lc = $(shell echo $1 | tr "A-Z" "a-z")
else
  uc = $(call tr,$([a-z]),$([A-Z]),$1)
  lc = $(call tr,$([A-Z]),$([a-z]),$1)
endif

# OK, now we can actually use these functions to figure out the names
# of the module files:

ifneq "$(words $(Modules))" "0"
ifeq "$(ModuleCase)" "UPPER"
  MODULES = $(call uc,$(Modules))
else
  ifeq "$(ModuleCase)" "lower"
    MODULES = $(call lc,$(Modules))
  else
    MODULES = $(Modules)
  endif
endif
  ModuleFiles = $(MODULES:%= $(PackageTargetDir)/%.$(ModSuffix))
  ParallelModuleFiles = $(MODULES:%= $(PackageParallelTargetDir)/%.$(ModSuffix))
endif
#
###########################################################################

ThirdPartyJarsTmp = $(patsubst %,$(LibDir)/%,$(JavaLibraries))
ThirdPartyJars    = $(subst $(Space),$(X),$(ThirdPartyJarsTmp))

ifneq "$(words $(JavaFiles))" "0"
  JavaPackageName   = $(subst /,.,$(Package))
  JarFile           = $(LibDir)/$(subst /,,$(Package)).jar
endif

#if Main is defined, do not build library. It may not be true sometimes
ifneq  "$(words $(ObjectFiles) $(ParallelObjectFiles))" "0"
  DependencyFile    = $(PackageSourceDir)/Makedepend
  ifneq "$(words $(Main))" "0"
    Executable             = $(BinDir)/$(Main)
    ifeq "$(BuiltParallelExe)" "1"
      ParallelExecutable     = $(BinDir)/$(Main)_MPI
    endif
  else
    SharedLibrary          = $(LibDir)/lib$(subst /,,$(patsubst %,oopse_%,$(Package)))_UP.so
    StaticLibrary          = $(LibDir)/lib$(subst /,,$(patsubst %,oopse_%,$(Package)))_UP.a
    ParallelSharedLibrary  = $(LibDir)/lib$(subst /,,$(patsubst %,oopse_%,$(Package)))_MPI.so
    ParallelStaticLibrary  = $(LibDir)/lib$(subst /,,$(patsubst %,oopse_%,$(Package)))_MPI.a
  endif
endif

#
# Misc
#
ClassPath        = $(JRE)$(X)$(TargetDir)$(X)$(ThirdPartyJars)
JavaPackageNames = $(subst /,.,$(JavaPackages))
IncludePath      = -I$(SourceDir) $(IncludeDirs:%=-I%)
LibDirs          = -L$(LibDir)    $(LibraryDirs:%=-L%)
LocalLibs        = $(subst /,,$(patsubst %, oopse_%_UP, $(PackageLibs)))
ParallelLocalLibs= $(subst /,,$(patsubst %, oopse_%_MPI, $(PackageLibs))) 
LibList          = $(LocalLibs:%=-l%) $(Libraries)
LibNames         = $(LocalLibs:%=$(LibDir)/lib%.a)
ParallelLibList  = $(ParallelLocalLibs:%=-l%) $(Libraries)
ParallelLibNames = $(ParallelLocalLibs:%=$(LibDir)/lib%.a)


#---------------------------------------------------------------------------
#
#  Tools & Options
#
#---------------------------------------------------------------------------
Print                  = @echo
Move                   = mv -f
Copy                   = cp
CCompiler              = @CC@
CppCompiler            = @CXX@
Linker                 = @CXX@
MakeDepend             = makedepend
INSTALL                = @INSTALL@
InstallProgram         = @INSTALL_PROGRAM@
InstallScript          = @INSTALL_SCRIPT@
InstallData            = @INSTALL_DATA@
MkDir                  = @MKINSTALLDIRS@
Delete                 = rm -f
StaticArchiver         = @AR@
DynamicArchiver        = @CC@
FortranCompiler        = @FC@
F90Compiler            = @F90@
JavaCompiler           = $(JAVA_HOME)/bin/javac
JavaArchiver           = $(JAVA_HOME)/bin/jar
JarSigner              = $(JAVA_HOME)/bin/jarsigner
JavadocGenerator       = $(JAVA_HOME)/bin/javadoc
JniCompiler            = $(JAVA_HOME)/bin/javah
RmiCompiler            = $(JAVA_HOME)/bin/rmic
JavaExecute            = $(JAVA_HOME)/bin/java
Purify                 = purify
WordCount              = wc
List                   = cat
Yacc                   = @YACC@
Lex                    = @LEX@
Ranlib                 = @RANLIB@
Doxygen                = @DOXYGEN@

MakeOptions            = -k
MakeDependOptions      = 
StaticArchiverOptions  = rc
DynamicArchiverOptions = -shared
JavaArchiverOptions    =
JniOptions             =
RmiOptions             = -d $(TargetDir) -classpath $(ClassPath) \
			 -sourcepath $(SourceDir)
COptions               = $(FrcDeclare) @CFLAGS@
CParallelOptions       = $(FrcDeclare) $(ParallelDeclare) @CFLAGS@
CppOptions             = $(FrcDeclare) @CXXFLAGS@ @OOPSE_TEMPLATE_FLAGS@
CppParallelOptions     = $(FrcDeclare) $(ParallelDeclare) @CXXFLAGS@ @OOPSE_TEMPLATE_FLAGS@
FortranOptions         =
F90Options             =  @PREPFLAG@ @F90FLAGS@ @MODDIRFLAG@$(SourceDir) @MODDIRFLAG@$(TargetDir) 
F90ParallelOptions     =  @PREPFLAG@ @F90FLAGS@ @MODDIRFLAG@$(SourceDir) @MODDIRFLAG@$(ParallelTargetDir)  @PREPDEFFLAG@$(ParallelDeclare)
JavaCompilerOptions    = -d $(TargetDir) -classpath $(ClassPath) \
			 -sourcepath $(SourceDir) -deprecation
JavaRunOptions         = -classpath $(ClassPath) 
PurifyOptions          = 
JavadocOptions         = -d $(DocsDir) \
			 -sourcepath $(SourceDir) \
			 -classpath $(ClassPath) \
			 -author \
			 -package \
			 -use \
			 -splitIndex \
			 -version \
			 -link file:$(JAVA_HOME)/docs/api \
			 -windowtitle $(JavadocWindowTitle) \
			 -doctitle $(JavadocDocTitle) \
			 -header $(JavadocHeader) \
			 -bottom $(JavadocFooter)
WordCountOptions       = --lines

Empty                  =
Space                  = $(Empty) $(Empty)


#---------------------------------------------------------------------------
#
#  Install
#
#---------------------------------------------------------------------------

ifneq "$(words $(SampleFiles))" "0"
  MySample                 = $(subst $(shell cd $(DEV_ROOT)/samples; pwd)/,,$(CurrentDir))
  MyInstallDir             = $(SampleSimDir)/$(MySample)
  InstallFiles             = $(SampleFiles)
  InstallCommand           = $(InstallData)
endif

ifneq "$(words $(Main))" "0"
  MyInstallDir             = $(InstallBinDir)
  ifeq "$(UseMPI)" "yes"
    InstallFiles             = $(Executable) $(ParallelExecutable)
  else
    InstallFiles             = $(Executable)
  endif 
  InstallCommand           = $(InstallProgram)
endif

ifneq "$(words $(ForcefieldFiles))" "0"
  MyInstallDir             = $(ForceParamDir)
  InstallFiles             = $(ForcefieldFiles)
  InstallCommand           = $(InstallData)
endif

ifneq "$(words $(InstallFiles))" "0"
  InstallList            =
else
  InstallList            = $(patsubst %,$(DEV_ROOT)/%,$(Samples)) $(DEV_ROOT)/forceFields $(patsubst %, $(SourceDir)/%,$(Applications)) 
endif

InstallListLoop          = $(patsubst %,$(SourceDir)/%/.install,$(PackageList))  $(patsubst %,%/.install,$(InstallList)) 



#---------------------------------------------------------------------------
#
# Rules
#
#---------------------------------------------------------------------------
default : build

%.loop :
	@$(MAKE) $(MakeOptions) -C $(subst .loop,,$@) _$(MAKECMDGOALS)all

# Create target directory
$(PackageTargetDir) :
	$(MkDir) $@

$(BinDir) :
	$(MkDir) $@

# .c -> .o
$(PackageTargetDir)/%.o : %.c $(MainMakefile)
	$(Print) $@
	$(CCompiler) $(COptions) -c $(IncludePath) $< -o $@

$(PackageParallelTargetDir)/%.o : %.c $(MainMakefile)
	$(Print) $@
	$(CCompiler) $(CParallelOptions) -c $(IncludePath) $< -o $@

ifeq "$(UseMPI)" "yes"
%.o : %.c $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
	$(MAKE) $(MakeOptions) $(PackageParallelTargetDir)/$@
else
%.o : %.c $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
endif

# .cpp -> .o
$(PackageTargetDir)/%.o : %.cpp $(MainMakefile)
	$(CppCompiler) $(CppOptions) -c $(IncludePath) $< -o $@

$(PackageParallelTargetDir)/%.o : %.cpp $(MainMakefile)
	$(CppCompiler) $(CppParallelOptions) -c $(IncludePath) $< -o $@

ifeq "$(UseMPI)" "yes"
%.o : %.cpp $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
	$(MAKE) $(MakeOptions) $(PackageParallelTargetDir)/$@
else
%.o : %.cpp $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
endif

# .f -> .o
$(PackageTargetDir)/%.o : %.f $(MainMakefile)
	$(FortranCompiler) $(FortranOptions) -c $< -o $@

$(PackageParallelTargetDir)/%.o : %.f $(MainMakefile)
	$(FortranCompiler) $(FortranParallelOptions) -c $< -o $@

ifeq "$(UseMPI)" "yes"
%.o : %.f $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
	$(MAKE) $(MakeOptions) $(PackageParallelTargetDir)/$@
else
%.o : %.f $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
endif

# .F90 -> .o
$(PackageTargetDir)/%.o : %.F90 $(MainMakefile)
	$(F90Compiler) $(F90Options) $(IncludePath) -c $< -o $@
	if test -n "`ls *.$(ModSuffix)`"; then \
	  $(Move) `ls *.$(ModSuffix)` $(PackageTargetDir);\
	fi

$(PackageParallelTargetDir)/%.o : %.F90 $(MainMakefile)
	$(F90Compiler) $(F90ParallelOptions) $(IncludePath) -c $< -o $@
	if test -n "`ls *.$(ModSuffix)`"; then \
	  $(Move) "`ls *.$(ModSuffix)`" $(PackageParallelTargetDir);\
	fi

ifeq "$(UseMPI)" "yes"
%.o : %.F90 $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
	if test -n "`ls *.$(ModSuffix)`"; then\
          $(Move) "`ls *.$(ModSuffix)`" $(PackageTargetDir);\
        fi

	$(MAKE) $(MakeOptions) $(PackageParallelTargetDir)/$@
	if test -n "`ls *.$(ModSuffix)`"; then\
	  $(Move) "`ls *.$(ModSuffix)`" $(PackageTargetDir);\
	fi

else
%.o : %.F90 $(MainMakefile)
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@
	if test -n "`ls *.$(ModSuffix)`"; then\
          $(Move) "`ls *.$(ModSuffix)`" $(PackageTargetDir);\
        fi
endif


# .java -> .class
$(PackageTargetDir)/%.class : $(PackageSourceDir)/%.java
	$(JavaCompiler) $(JavaCompilerOptions) $< 

%.class : $(PackageSourceDir)/%.java
	@$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@

# .class -> .h
$(PackageSourceDir)/%.h : $(PackageTargetDir)/%.class
	$(JniCompiler) $(JniOptions) $(JavaPackageName).$*

%.h : %.class
	$(MAKE) $(MakeOptions) $(PackageSourceDir)/$@

#.y -> .h
%.h : %.y
	$(Yacc) -d  $?
	@$(Move) y.tab.h $*.h
	@$(Delete) y.tab.c

#.y -> .c
%.c : %.y
	$(Yacc) -d  $?
	@$(Move) y.tab.c $*.c
	@$(Delete) y.tab.h

# .l -> .c
%.c : %.l
	$(Print) $@
	$(Print) $(Lex) -o$@ $?
	@$(Lex) -o$@ $?

# .o -> .a

$(LibDir)/%_UP.a : $(ObjectFiles)
	$(StaticArchiver) $(StaticArchiverOptions) $@ $(ObjectFiles)
	@touch $(LibDir)/.stamp_UP

$(LibDir)/%_MPI.a: $(ParallelObjectFiles)
	$(StaticArchiver) $(StaticArchiverOptions) $@ $(ParallelObjectFiles)
	@touch $(LibDir)/.stamp_MPI

%_UP.a : $(ObjectFiles)
	$(MAKE) $(MakeOptions) $(LibDir)/$@

%_MPI.a : $(ParallelObjectFiles)
	$(MAKE) $(MakeOptions) $(LibDir)/$@

# .o -> .so
$(LibDir)/%_UP.so : $(ObjectFiles)
	$(DynamicArchiver) $(ObjectFiles) $(DynamicArchiverOptions) -o $@

$(LibDir)/%_MPI.so : $(ParallelObjectFiles)
	$(DynamicArchiver) $(ParallelObjectFiles) $(DynamicArchiverOptions) -o $@

%_UP.so : $(ObjectFiles)
	$(MAKE) $(MakeOptions) $(LibDir)/$@

%_MPI.so : $(ParallelObjectFiles)
	$(MAKE) $(MakeOptions) $(LibDir)/$@

# .class -> .jar
$(LibDir)/%.jar : $(JavaClassFiles) $(OtherTargetFiles)
	$(Print) $@
	@cd $(TargetDir); $(JavaArchiver) -cf $@ \
	$(JavaClassFilesRel) $(OtherTargetFiles)

%.jar : $(JavaClassFiles) $(OtherTargetFiles)
	$(MAKE) $(MakeOptions) $(LibDir)/$@

# .class -> JavaDoc
javadoc : 
	$(Print) $(JavaPackageNames) > $(DEV_ROOT)/packages.tmp
	$(JavadocGenerator) $(JavadocOptions) @$(DEV_ROOT)/packages.tmp
	$(Delete) $(DEV_ROOT)/packages.tmp
	$(Print) Done JavaDoc.

# .class -> _Stub.class 
$(PackageTargetDir)/%_Stub.class : $(PackageTargetDir)/%.class
	$(Print) $@
	$(RmiCompiler) $(RmiOptions) $(JavaPackageName).$*

%_Stub.class : %.class
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@

# .class -> _Skel.class
$(PackageTargetDir)/%_Skel.class : $(PackageTargetDir)/%.class
	$(Print) $@
	$(RmiCompiler) $(RmiOptions) $(JavaPackageName).$*

%_Skel.class : %.class
	$(MAKE) $(MakeOptions) $(PackageTargetDir)/$@

document :
	$(Print) Generate Documentation for OOPSE-2.0
	@cd $(DEV_ROOT)/src	
	$(Doxygen) $(DEV_ROOT)/make/Doxyfile

#GUN make funtions to merge the libraries
find_objs = $(shell $(StaticArchiver) -t $(1))
extract_objs = $(shell $(StaticArchiver) -x $(1) $(call find_objs, $(1)))
create_archive = $(shell  $(StaticArchiver) $(StaticArchiverOptions) $(2) $(call find_objs, $(1)))
remove_objs = $(shell $(Delete) $(call find_objs, $(1)))
do_create = $(call extract_objs,$(1))$(call create_archive,$(1),$(2))$(call remove_objs,$(1))  

$(CombinedStaticLib) : $(LibDir)/.stamp_UP
	$(Print) create $@     	
	$(foreach thisLib,$(LibNames),$(call do_create,$(thisLib),$@))
	$(Ranlib) $(CombinedStaticLib)

$(CombinedParallelStaticLib) : $(LibDir)/.stamp_MPI
	$(Print) create $@
	$(foreach thisLib,$(ParallelLibNames), $(call do_create, $(thisLib), $@))
	$(Ranlib) $(CombinedParallelStaticLib)

# Executable
$(Executable) : $(CombinedStaticLib) $(ObjectFiles) $(BinDir)
	$(Linker) $(ObjectFiles) $(CombinedStaticLib) $(LinkOptions) $(LibDirs) $(Libraries) -o $@

$(ParallelExecutable) : $(CombinedParallelStaticLib) $(ParallelObjectFiles) $(BinDir)
	$(Linker) $(ParallelObjectFiles) $(CombinedParallelStaticLib) $(ParallelLinkOptions) $(LibDirs) $(Libraries) -o $@

# Anything else is just copied from source to target
$(PackageTargetDir)/% : $(PackageSourceDir)/%
	$(Print) $@
	$(Copy) $< $@

# make (or make build)
build : $(PackageListLoop)
	$(Print) Done build.

_all : _buildall

_buildall : 
ifeq "$(UseMPI)" "yes"
_buildall : \
	$(DependencyFile) \
	$(PackageTargetDir) \
	$(ObjectFiles) \
	$(ParallelObjectFiles) \
	$(JavaClassFiles) \
	$(RmiStubFiles) \
	$(RmiSkeletonFiles) \
	$(OtherTargetFiles) \
	$(StaticLibrary) \
	$(ParallelStaticLibrary) \
	$(JarFile) \
	$(Executable) \
	$(ParallelExecutable) 
else
_buildall : \
	$(DependencyFile) \
	$(PackageTargetDir) \
	$(ObjectFiles) \
	$(JavaClassFiles) \
	$(RmiStubFiles) \
	$(RmiSkeletonFiles) \
	$(OtherTargetFiles) \
	$(StaticLibrary) \
	$(JarFile) \
	$(Executable) 
endif

echo : $(PackageListLoop)
	$(Print) Done echo.

_echoall :
	$(Print) $(Modules)

# make clean
clean : $(PackageListLoop)
	$(Print) Done clean.	

_cleanall :
	$(Delete) \
		$(ObjectFiles) \
		$(ModuleFiles) \
		$(ParallelObjectFiles) \
		$(ParallelModuleFiles) \
		$(JarFile) \
		$(SharedLibrary) \
		$(StaticLibrary) \
		$(ParallelSharedLibrary) \
		$(ParallelStaticLibrary) \
		$(CombinedStaticLib) \
		$(CombinedParallelStaticLib)

# make distclean
distclean : $(PackageListLoop)
	$(Print) Done clean.	

_distcleanall : _cleanall
	$(Delete) $(Executable) \
	          $(ParallelExecutable) \
	          $(DependencyFile) 

# make depend
depend : $(PackageListLoop)
	$(Print) Done dependencies.

_dependall : $(DependencyFile)

$(DependencyFile) : $(DerivedSource)
	$(Print) $@ 
	@cd $(PackageSourceDir)

ifneq "$(words $(CppFiles))" "0"
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(TargetDir)/' -MM $(CppFiles)>> Make.cpptemp
	@cat Make.cpptemp  >> $(DependencyFile)
	$(Delete) Make.cpptemp

  ifeq "$(UseMPI)" "yes"
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(ParallelTargetDir)/' $(ParallelDeclare) -MM $(CppFiles)>> Make.cpptemp
	@cat Make.cpptemp  >> $(DependencyFile)
	@$(Delete) Make.cpptemp
  endif

endif

ifneq "$(words $(CFiles))" "0" 
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(TargetDir)/'  -MM $(CFiles) $(DerivedCFiles)  >> Make.ctemp
	@cat Make.ctemp  >> $(DependencyFile)
	$(Delete) Make.ctemp

  ifeq "$(UseMPI)" "yes"
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(ParallelTargetDir)/' $(ParallelDeclare) -MM $(CFiles) $(DerivedCFiles)  >> Make.ctemp
	@cat Make.ctemp  >> $(DependencyFile)
	@$(Delete) Make.ctemp
  endif

endif

ifneq "$(words $(F90Files))" "0"
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(TargetDir)/' $(F90Declare) -MM -mc $(ModuleCase) -ms $(ModSuffix) $(F90Files) > Make.ftemp
	@cat Make.ftemp >> $(DependencyFile)
	@$(Delete) Make.ftemp

  ifeq "$(UseMPI)" "yes"
	$(DEV_ROOT)/scripts/filepp  -I $(DEV_ROOT)/src -od '$$(ParallelTargetDir)/' $(ParallelDeclare) $(F90Declare) -MM -mc $(ModuleCase) -ms $(ModSuffix)  $(F90Files) >> Make.ftemp
	@cat Make.ftemp >> $(DependencyFile)
	@$(Delete) Make.ftemp
  endif

endif

# make lib
lib    : $(PackageListLoop)
	$(Print) Libraries built.

_liball : $(JarFile) $(SharedLibrary) $(StaticLibrary)

jar : $(JarFile)

jarsign : $(JarFile)
	$(JarSigner) -keystore GeoSoftKeystore $(JarFile) myself

#make install
%.install :
	@$(MAKE) $(MakeOptions) -C $(subst .install,,$@) _installall 	

install : $(InstallListLoop)
	$(Print) Done Install

_installall : _buildall _installdata

$(MyInstallDir) : 
	$(MkDir) $@

_installdata :  $(MyInstallDir)
	$(Print) $(InstallFiles) 
ifneq "$(words $(InstallFiles))" "0"
	$(InstallCommand) $(InstallFiles) $(MyInstallDir)
endif	    

# make statistics
_statisticsall :
	@$(Print) $(patsubst %,$(CurrentDir)/%,$(SourceFiles)) >> $(DEV_ROOT)/files.tmp

statistics : $(PackageListLoop)
	@$(List) $(DEV_ROOT)/files.tmp | xargs $(WordCount) $(WordCountOptions)
	@$(Delete) $(DEV_ROOT)/files.tmp
	$(Print) Done statistics.

# make pure
#$(Executable).pure :
#	$(Purify) $(PurifyOptions) $(CppCompiler) $(LinkOptions) $(LibDirs) \
#	$(LibList) $(ObjectFiles) -o $@
#
#pure : $(Executable).pure

#make cvslog
cvslog:
	$(DEV_ROOT)/scripts/cvs2cl

# Execute
_runexe :
	$(Executable) $(RunParameters)

_runjava :
	$(JavaExecute) $(JavaRunOptions) $(JavaMainClass) $(RunParameters)

run : _runjava


ifdef $(DependencyFile)
-include $(DependencyFile)
endif
